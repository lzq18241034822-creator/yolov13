收到！按你的唯一方案 µScale-HyperMorph-YOLO（µSHM-YOLO）落地，我给你两样东西：
- 最新版 YAML（引入“多细胞：>4”新范畴，ID=44，并与旧10/11做兼容映射）
- 自定义标注软件代码（GUI，按YAML自动加载类目，保存为统一TXT；兼容旧标签，新增“多细胞(>4)”可选）

一、最新版 YAML（Unified-Final-2.1）
说明：
- 新增全局类 44: multicellular_gt4（中文：多细胞(>4)）
- cell_organization 训练用4类：单(7)、双(8)、四(9)、多(>4=44)
- 兼容旧标签：10(dense_colony) 与 11(colonial_cluster) 在训练映射到“多(>4)”的同一局部索引
- 规则引擎已改：涉及群体的约束优先使用 44，多处保留旧10/11作为兼容

保存为 configs/yolov13_transformer_unified_v2_1.yaml

```yaml
# ═══════════════════════════════════════════════════════════════════════════
# µSHM-YOLO (µScale-HyperMorph-YOLO) Unified Config
# Version: Unified-Final-2.1  (add multicellular_gt4=44; cell_org uses 7/8/9/44)
# ═══════════════════════════════════════════════════════════════════════════

project:
  name: "µSHM-YOLO"
  version: "Unified-Final-2.1"
  note: "µScale + Mask2Morph + Hypergraph + SoftRule + GeometryDual"
  description: "微尺度像素注入与超图属性耦合的一体化微藻检测-分割-多属性识别与形态测量"
  key_features:
    - "统一标注：每图一TXT（5ID + bbox + polygon），头部注入µm/px"
    - "P2 + RepGFPN + 可选DCNv3：小目标增强"
    - "µScale像素尺度注入：跨批次度量一致"
    - "Mask2Morph：检测-分割-五属性端到端"
    - "超图增强：cell_organization（单/双/四/多>4）提升"
    - "软规则 + 几何一致性：减少冲突，稳测量"

pipeline:
  stage1: {name: "全局检测", input: "完整图像", use_annotation: "bbox+seg（忽略分类）", output: "实例bbox+mask", model: "YOLO-Seg"}
  stage1_mask2morph: {name: "一体化五属性", input: "Stage1实例ROI", output: "5属性ID", model: "Mask2Morph Decoder"}
  stage2: {name: "ROI分类（蒸馏辅助）", input: "Stage1导出ROI", output: "5属性软标签", model: "Transformer Decoder", enabled: true}
  stage3: {name: "整合分析", input: "检测+五属性", output: "规则检查 + 物理参数", model: "Rule Engine + CV"}

dataset:
  path: "E:/yolov13/microalgae_unified_dataset"
  train: "images/train"
  val: "images/val"
  test: "images/test"
  labels:
    train: "labels/train"
    val: "labels/val"
    test: "labels/test"

  naming:
    enable_label_prefix: true
    label_filename_template: "{magnification}-{pixel_size_um}um_{image_stem}.txt"
    number_format:
      pixel_size_um: {digits: 4, trim_trailing_zeros: false}
    sanitize:
      to_lowercase: false
      replace: {"×": "x", " ": "_"}
      remove_chars: ["[", "]", "(", ")", "{", "}", ":", ";"]
    enforce_in_validator: true
    auto_inject_header: true
    header_lines:
      - "# magnification: {magnification}"
      - "# pixel_size_um: {pixel_size_um}"
      - "# pixel_dimensions_px: {pixel_dimensions_px}"
      - "# magnification_camera: {magnification_camera}"
      - "# pixel_size_um_source: {pixel_size_um_source}"
    preview_examples:
      - input_image: "img001.jpg"
        output_label: "400x-0.0863um_img001.txt"

  annotation_format:
    format_name: "YOLOv13-Transformer-Unified"
    version: "1.0"
    description: |
      每图一TXT；每行= 5分类ID（全局） + 4归一化bbox + Polygon分割点（归一化x,y成对）
      species cell_org shape flagella chloroplast xc yc w h x1 y1 ... xn yn
    parsing_rules:
      step1: "空格切分"
      step2: "前5 → classification_info"
      step3: "第6-9 → bbox_info"
      step4: "第10起 → segmentation_points（偶数）"
      step5: "校验范围与归一化[0,1]"
    header_metadata:
      fields:
        - {key: "magnification", type: "string", example: "400x"}
        - {key: "pixel_size_um", type: "float", example: 0.0863}
        - {key: "pixel_dimensions_px", type: "string", example: "3072x2048"}
        - {key: "magnification_camera", type: "string", example: "40x"}
        - {key: "pixel_size_um_source", type: "string", example: "assumed(3.45um_pixel/40x_camera)"}

microscope:
  magnification: "400x"
  pixel_dimensions_px: "3072x2048"
  pixel_size_um: 0.0863
  magnification_camera: "40x"
  pixel_size_um_source: "assumed(3.45um_pixel/40x_camera)"
  assumptions:
    objective_magnification: 40
    relay_magnification: 1.0
    total_magnification_camera: 40
    sensor_pixel_pitch_um_assumed: 3.45
    source_note: "相机端不经10x目镜；如更新真实像元/中继镜，直接改 pixel_size_um"

dataset_stats:
  mean: [0.485, 0.456, 0.406]
  std:  [0.229, 0.224, 0.225]

classes:
  nc: 45
  names:
    0: chlorella_vulgaris
    1: chlamydomonas_reinhardtii
    2: scenedesmus_quadricauda
    3: scenedesmus_obliquus
    4: pediastrum_boryanum
    5: synedra_acus
    6: microcystis_aeruginosa
    7: single_cell
    8: pair_cells
    9: quartet_cells
    10: dense_colony
    11: colonial_cluster
    12: spherical
    13: ovoid
    14: ellipsoidal
    15: stellate
    16: irregular_grid
    17: discoid
    18: radiate_colony
    19: rod_shaped
    20: acicular
    21: gelatinous_sphere
    22: no_flagella
    23: one_flagellum
    24: two_flagella
    25: three_flagella
    26: four_flagella
    27: chloroplast_rich
    28: chloroplast_moderate
    29: chloroplast_poor
    30: chloroplast_trace
    31: uncertain_chlorella
    32: uncertain_chlamydomonas
    33: uncertain_scenedesmus_q
    34: uncertain_scenedesmus_o
    35: uncertain_pediastrum
    36: uncertain_synedra
    37: uncertain_microcystis
    38: cell_fragment
    39: abnormal_cell
    40: unidentifiable_object
    41: air_bubble
    42: background_artifact
    43: high_density_zone
    44: multicellular_gt4
  names_zh:
    0: 小球藻
    1: 衣藻
    2: 四尾栅藻
    3: 斜生栅藻
    4: 盘星藻
    5: 针杆藻
    6: 微囊藻
    7: 单细胞
    8: 双细胞
    9: 四细胞
    10: 密集群体（旧）
    11: 群体簇集（旧）
    12: 球形
    13: 卵形
    14: 椭圆形
    15: 星状
    16: 不规则栅状
    17: 盘状
    18: 放射状群体
    19: 杆状
    20: 针状
    21: 胶状球体
    22: 无鞭毛
    23: 1根鞭毛
    24: 2根鞭毛
    25: 3根鞭毛
    26: 4根鞭毛
    27: 叶绿体丰富
    28: 叶绿体中等
    29: 叶绿体稀少
    30: 叶绿体痕量
    31: 疑似小球藻
    32: 疑似衣藻
    33: 疑似四尾栅藻
    34: 疑似斜生栅藻
    35: 疑似盘星藻
    36: 疑似针杆藻
    37: 疑似微囊藻
    38: 细胞碎片
    39: 异常细胞
    40: 不可识别
    41: 气泡
    42: 背景伪影
    43: 高密度区
    44: 多细胞(>4)
  groups:
    species: {classes: [0,1,2,3,4,5,6,31,32,33,34,35,36,37,38,39,40,41,42,43], range: [0, 43]}
    cell_organization: {classes: [7,8,9,44], range: [7, 44]}   # 训练用4类
    shape: {classes: [12,13,14,15,16,17,18,19,20,21], range: [12, 21]}
    flagella: {classes: [22,23,24,25,26], range: [22, 26]}
    chloroplast: {classes: [27,28,29,30], range: [27, 30]}
  label_spaces:
    species: {to_local: "identity", to_global: "identity"}
    cell_org:
      # 训练映射（兼容旧10/11 → 多(>4)）
      to_local: {7:0, 8:1, 9:2, 44:3, 10:3, 11:3}
      to_global: {0:7, 1:8, 2:9, 3:44}
    shape:
      to_local: {12:0,13:1,14:2,15:3,16:4,17:5,18:6,19:7,20:8,21:9}
      to_global: {0:12,1:13,2:14,3:15,4:16,5:17,6:18,7:19,8:20,9:21}
    flagella:
      to_local: {22:0,23:1,24:2,25:3,26:4}
      to_global: {0:22,1:23,2:24,3:25,4:26}
    chloroplast:
      to_local: {27:0,28:1,29:2,30:3}
      to_global: {0:27,1:28,2:29,3:30}

model:
  type: "µSHM_YOLO"

  pixel_scale_conditioning:
    enabled: true
    method: "FiLM"
    norm: "log_ratio"
    base_pixel_size_um: 0.0863
    injection_stages: ["backbone.s3","backbone.s4","neck.p3","neck.p2"]

  stage1_detection:
    task: "instance_segmentation"
    backbone:
      type: "CSPDarknet"
      depth: "l"
      width: 1.0
      pretrained: true
      local_vit: {enabled: true, insert_stages: [3, 4], window_size: 7, depth: 2, num_heads: 8}
      dcnv3: {enabled: true, stages: [3,4]}
    neck:
      type: "RepGFPN"
      in_channels: [256, 512, 1024]
      out_channels: 256
      add_p2: true
      reparam: true
      deformable_transformer: {enabled: true, d_model: 256, nhead: 8, num_layers: 3}
    head:
      type: "YOLOv8_Seg_Head"
      nc: 1
      nm: 32
      mask_sample_points: 100
      ignore_classification_info: true
      use_unified_class: true
      unified_class_id: 0
    output: {bbox: true, mask: true, confidence: true}

  mask2morph_head:
    enabled: true
    roi_align: {size: 224, sampling_ratio: 2, aligned: true, from_scales: [0.125, 0.0625, 0.03125]}
    decoder: {type: "MPT_Decoder", d_model: 512, nhead: 8, num_layers: 4, dim_feedforward: 2048, dropout: 0.1}
    prior_tokens: {enabled: true, num_tokens: 24, dim: 512, init: "normal", inject_layer: 0}
    queries:
      species: {num: 1, dim: 512}
      cell_org: {num: 1, dim: 512}
      shape: {num: 1, dim: 512}
      flagella: {num: 1, dim: 512}
      chloroplast: {num: 1, dim: 512}
    heads:
      species: {num_classes: 45, loss: "cross_entropy", weight: 2.0}  # 全局类45
      cell_org: {num_classes: 4, loss: "cross_entropy", weight: 1.0}  # 单/双/四/多
      shape: {num_classes: 10, loss: "cross_entropy", weight: 1.0}
      flagella: {num_classes: 5, loss: "cross_entropy", weight: 1.0}
      chloroplast: {num_classes: 4, loss: "cross_entropy", weight: 1.0}
    output: {format: "5_class_ids", decode_to_global: true}

  colony_hypergraph:
    enabled: true
    edge_build: {k: 8, dist_sigma_px: 40, angle_sigma_deg: 20, touch_bonus: 0.2}
    hyperedge: {pair: true, quartet: true}
    gnn: {type: "LightGraphTransformer", layers: 2, d_model: 256, nhead: 4, dropout: 0.1}
    loss_weight: 0.5

stage3_integration:
  rule_engine:
    enabled: true
    mode: "hard"
    species_morphology_rules:
      - {species: 0, required: {cell_org: [7], shape: [12,13,14], flagella: [22]}, forbidden: {cell_org: [8,9,44,10,11], flagella: [23,24,25,26]}}
      - {species: 1, required: {cell_org: [7], shape: [12,13,14], flagella: [23,24]}, forbidden: {flagella: [22,25,26]}}
      - {species: 2, required: {cell_org: [9], shape: [16], flagella: [23,24,25,26]}, forbidden: {flagella: [22]}}
      - {species: 3, required: {cell_org: [9], shape: [15,16], flagella: [22]}}
      - {species: 4, required: {cell_org: [9,44,10,11], shape: [17,18], flagella: [22]}}
      - {species: 5, required: {cell_org: [7], shape: [19,20], flagella: [22]}}
      - {species: 6, required: {cell_org: [7,44,10,11], shape: [12,21], flagella: [22]}}
  parameter_calculator:
    enabled: true
    input_source: "stage1_masks"
    parameters:
      - {name: "cell_density", method: "mask_instance_counting", unit: "cells/mm²"}
      - {name: "aspect_ratio", method: "min_area_rect", unit: "ratio"}
      - {name: "boundary_complexity", method: "perimeter_area_ratio", unit: "index"}
      - {name: "fractal_dimension", method: "box_counting", unit: "dimension"}
      - {name: "compactness", method: "area_perimeter_ratio", unit: "ratio"}
      - {name: "ellipse_similarity", method: "fit_ellipse_iou", unit: "similarity"}
      - {name: "chlorophyll_content", method: "green_channel_index", unit: "relative"}
      - {name: "aggregation_degree", method: "nearest_neighbor_cv", unit: "degree"}
      - {name: "size_uniformity", method: "area_cv", unit: "uniformity"}
      - {name: "orientation_orderliness", method: "nematic_order_parameter", unit: "order"}

training:
  soft_constraints:
    enabled: true
    violation_penalty: 0.2
    allowed_variations_boost: 0.1
    conf_gate: 0.7

  geometry_consistency:
    enabled: true
    targets: [area_um2, perimeter_um, major_minor_axis_um, compactness]
    loss: "smooth_l1"
    weight: 0.5

  stage1_training:
    enabled: true
    epochs: 300
    batch_size: 16
    imgsz: 640
    workers: 8
    device: "0"
    dataloader:
      annotation_parser: "unified_format"
      use_fields: ["bbox", "segmentation"]
      ignore_fields: ["classification"]
      convert_to_single_class: true
      stage1_class_filter: {mode: "skip", skip_species_ids: [41, 42, 43, 40]}
      normalize: {to_rgb: true, mean: [0.485, 0.456, 0.406], std: [0.229, 0.224, 0.225]}
    optimizer: {type: "AdamW", lr: 0.001, weight_decay: 0.0005}
    lr_scheduler: {type: "cosine", warmup_epochs: 3, min_lr: 1.0e-5}
    loss_weights: {box: 7.5, cls: 0.5, dfl: 1.5, mask: 2.5}
    augmentation:
      hsv_h: 0.015
      hsv_s: 0.7
      hsv_v: 0.4
      degrees: 25.0
      translate: 0.1
      scale: 0.5
      flipud: 0.5
      fliplr: 0.5
      mosaic: 0.2
      mixup: 0.0
      gaussian_noise: 0.01
      gaussian_blur: 0.05
    save: {save_dir: "runs/stage1_detection", save_period: 10, save_best: true, metric: "metrics/mAP50(M)"}

  stage1_joint_multitask:
    enabled: true
    epochs: 150
    batch_size: 12
    imgsz: 640
    device: "0"
    open_modules: ["mask2morph_head", "colony_hypergraph"]
    losses:
      species: 2.0
      cell_org: 1.0
      shape: 1.0
      flagella: 1.0
      chloroplast: 1.0
      hypergraph: 0.5
      geom_consistency: 0.5
      soft_constraints: 0.2
    optimizer: {type: "AdamW", lr: 0.0006, weight_decay: 0.0003}
    lr_scheduler: {type: "one_cycle", max_lr: 0.0012, pct_start: 0.3}
    dataloader:
      use_predicted_roi_ratio: 0.5
      min_roi_size: 16
      expand_ratio: 1.2

  stage2_training:
    enabled: true   # 作为蒸馏辅助（训练期），推理期可禁用
    epochs: 150
    batch_size: 64
    roi_size: 224
    workers: 8
    device: "0"
    dataloader:
      annotation_parser: "unified_format"
      use_fields: ["classification", "bbox"]
      roi_cropping: {method: "from_bbox", expand_ratio: 1.2, min_size: 16, max_size: 512}
      label_extraction:
        species_id: "field_0"
        cell_org_id: "field_1"
        shape_id: "field_2"
        flagella_id: "field_3"
        chloroplast_id: "field_4"
        map_to_local_index: true
        id_maps_from: "classes.label_spaces"
        validation:
          species: [0, 44]  # 全局0..44
          cell_org: [7, 44] # 允许7/8/9/44（兼容10/11将被映射）
          shape: [12, 21]
          flagella: [22, 26]
          chloroplast: [27, 30]
      normalize: {to_rgb: true, mean: [0.485, 0.456, 0.406], std: [0.229, 0.224, 0.225]}
    optimizer: {type: "AdamW", lr: 0.0005, weight_decay: 0.0001}
    lr_scheduler: {type: "one_cycle", max_lr: 0.001, pct_start: 0.3}
    loss_weights: {species: 2.0, cell_org: 1.0, shape: 1.0, flagella: 1.0, chloroplast: 1.0}
    augmentation:
      rotation: [-180, 180]
      scale: [0.8, 1.2]
      flip: 0.5
      color_jitter: {brightness: 0.2, contrast: 0.2, saturation: 0.1, hue: 0.05}
      gaussian_noise: 0.02
      gaussian_blur: 0.1
    save: {save_dir: "runs/stage2_classification", save_period: 10, save_best: true, metric: "val/species_acc"}

inference:
  pipeline:
    step1_detection:
      model_path: "runs/stage1_detection/weights/best.pt"
      conf_threshold: 0.25
      iou_threshold: 0.45
      max_det: 300
      output: {bbox: true, mask: true, save_crops: true, crop_dir: "inference/roi_crops", expand_ratio: 1.2}
    mask2morph_inference:
      enabled: true
      batch_size: 32
      output: {species_id: true, cell_org_id: true, shape_id: true, flagella_id: true, chloroplast_id: true, confidences: true}
    hypergraph_inference:
      enabled: true
      max_nodes: 150
      apply_to: "cell_organization"
      merge_strategy: "confidence_weighted"
    step2_classification:
      enabled: false
    step3_integration:
      rule_engine: true
      parameter_calculation: true
      output: {format: "json", save_path: "inference/results/predictions.json", save_visualization: true, visualization_dir: "inference/results/visualizations"}
  output_schema:
    image_id: "string"
    detections:
      - roi_id: "int"
        bbox: "[x1, y1, x2, y2]"
        mask_path: "string"
        classification:
          species: {id: "int", name: "string", confidence: "float"}
          cell_org: {id: "int", name: "string", confidence: "float"}
          shape: {id: "int", name: "string", confidence: "float"}
          flagella: {id: "int", name: "string", confidence: "float"}
          chloroplast: {id: "int", name: "string", confidence: "float"}
        rule_check: {passed: "bool", violations: ["list"]}
        parameters:
          cell_density: "float"
          aspect_ratio: "float"
          boundary_complexity: "float"
          fractal_dimension: "float"
          compactness: "float"
          ellipse_similarity: "float"
          chlorophyll_content: "float"
          aggregation_degree: "float"
          size_uniformity: "float"
          orientation_orderliness: "float"

annotation_reference:
  description: "cell_organization 采用 7/8/9/44（>4）; 旧10/11会映射为44参与训练"
  examples:
    - "小球藻: 0 7 12 22 27"
    - "衣藻:   1 7 14 24 27"
    - "四尾栅藻: 2 9 16 26 28"
    - "微囊藻(多): 6 44 21 22 27"
```

二、自定义标注软件（GUI）代码
特点：
- 多边形标注 + 自动bbox + 5分类选择（从YAML读入）
- 自动注入头部与前缀命名（400x-0.0863um_imgXXX.txt）
- 新增“多细胞(>4)”选项（ID=44）；旧10/11 仍能被加载显示（不影响保存）
- 可加载已有标注并叠加显示；撤销一点/清空/删除选中标注

依赖安装：
- pip install PyQt5 ruamel.yaml opencv-python numpy

保存为 tools/unified_annotator_gui.py

```python
# -*- coding: utf-8 -*-
# 统一标注GUI：Polygon + BBox + 5ID（按YAML自动注入头部与命名）
# 运行:
#   python tools/unified_annotator_gui.py --image_dir images/train --output_dir labels/train --cfg configs/yolov13_transformer_unified_v2_1.yaml

import os
import sys
import cv2
import argparse
import numpy as np
from ruamel.yaml import YAML

from PyQt5.QtCore import Qt, QPoint
from PyQt5.QtGui import QImage, QPixmap, QPainter, QPen, QColor, QBrush
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QVBoxLayout, QHBoxLayout,
    QPushButton, QFileDialog, QComboBox, QListWidget, QListWidgetItem, QMessageBox
)

def load_yaml(path):
    yaml = YAML()
    with open(path, 'r', encoding='utf-8') as f:
        return yaml.load(f)

def fmt_pixel_size(val, digits=4, trim=False):
    s = f"{float(val):.{digits}f}"
    return s.rstrip('0').rstrip('.') if trim and '.' in s else s

def build_label_filename(tmpl, microscope, img_stem, nf_conf):
    px = fmt_pixel_size(microscope['pixel_size_um'],
                        nf_conf['pixel_size_um']['digits'],
                        nf_conf['pixel_size_um']['trim_trailing_zeros'])
    return tmpl.format(
        magnification=microscope.get('magnification', ''),
        pixel_size_um=px,
        pixel_dimensions_px=microscope.get('pixel_dimensions_px', ''),
        image_stem=img_stem
    )

def inject_headers(header_tmpl, microscope, nf_conf):
    px = fmt_pixel_size(microscope['pixel_size_um'],
                        nf_conf['pixel_size_um']['digits'],
                        nf_conf['pixel_size_um']['trim_trailing_zeros'])
    mapping = {
        '{magnification}': microscope.get('magnification', ''),
        '{pixel_size_um}': px,
        '{pixel_dimensions_px}': microscope.get('pixel_dimensions_px', ''),
        '{magnification_camera}': microscope.get('magnification_camera', ''),
        '{pixel_size_um_source}': microscope.get('pixel_size_um_source', ''),
    }
    outs = []
    for line in header_tmpl:
        s = line
        for k, v in mapping.items():
            s = s.replace(k, str(v))
        outs.append(s)
    return outs

class Config:
    def __init__(self, cfg_path):
        self.cfg = load_yaml(cfg_path)
        self.naming = self.cfg['dataset']['naming']
        self.number_format = self.naming['number_format']
        # 取显微镜信息（优先顶层microscope）
        if 'microscope' in self.cfg:
            self.microscope = self.cfg['microscope']
        elif 'microscope' in self.cfg['dataset']:
            self.microscope = self.cfg['dataset']['microscope']
        else:
            raise KeyError("YAML未找到 microscope 节点")
        self.classes = self.cfg['classes']
        self.groups = self.classes['groups']
        self.names = self.classes['names']

    def class_options(self):
        # GUI键到YAML group键
        mapping = {
            'species': 'species',
            'cell_org': 'cell_organization',
            'shape': 'shape',
            'flagella': 'flagella',
            'chloroplast': 'chloroplast'
        }
        opts = {}
        for gui_key, grp_key in mapping.items():
            ids = self.groups[grp_key]['classes']
            opts[gui_key] = [(i, self.names[i]) for i in ids]
        return opts

class Annotator(QMainWindow):
    def __init__(self, image_dir, output_dir, cfg: Config):
        super().__init__()
        self.setWindowTitle("微藻统一标注工具 (Polygon + BBox + 5ID)")
        self.image_dir = image_dir
        self.output_dir = output_dir
        self.cfg = cfg
        self.options = cfg.class_options()

        self.images = sorted([f for f in os.listdir(image_dir)
                              if f.lower().endswith(('.jpg','.jpeg','.png','.bmp','.tif','.tiff'))])
        self.idx = 0
        self.img = None
        self.img_h = 0
        self.img_w = 0
        self.view_w = 1200
        self.view_h = 800
        self.scale_x = 1.0
        self.scale_y = 1.0

        self.curr_poly = []   # 当前多边形点（原图坐标）
        self.annos = []       # 每条= [sp,co,sh,fl,ch, xc,yc,w,h, x1,y1,...]

        self.init_ui()
        if self.images:
            self.load_image()

    def init_ui(self):
        # 图像显示
        self.img_label = QLabel()
        self.img_label.setFixedSize(self.view_w, self.view_h)
        self.img_label.setStyleSheet("background:#222;")
        self.img_label.setCursor(Qt.CrossCursor)
        self.img_label.mousePressEvent = self.on_mouse_press

        # 右侧控件
        self.cb = {}
        for key in ['species','cell_org','shape','flagella','chloroplast']:
            cb = QComboBox()
            for _id, name in self.options[key]:
                cb.addItem(f"{_id} - {name}", _id)
            self.cb[key] = cb

        self.btn_add = QPushButton("添加标注(完成多边形)")
        self.btn_undo = QPushButton("撤销一点")
        self.btn_clear = QPushButton("清空多边形")
        self.btn_del = QPushButton("删除选中标注")
        self.btn_save = QPushButton("保存当前图")
        self.btn_prev = QPushButton("上一张")
        self.btn_next = QPushButton("下一张")

        self.btn_add.clicked.connect(self.add_anno)
        self.btn_undo.clicked.connect(self.undo_point)
        self.btn_clear.clicked.connect(self.clear_poly)
        self.btn_del.clicked.connect(self.del_selected)
        self.btn_save.clicked.connect(self.save_current)
        self.btn_prev.clicked.connect(self.prev_image)
        self.btn_next.clicked.connect(self.next_image)

        self.list_ann = QListWidget()

        right = QVBoxLayout()
        for k in ['species','cell_org','shape','flagella','chloroplast']:
            right.addWidget(QLabel(k+":"))
            right.addWidget(self.cb[k])
        right.addWidget(self.btn_add)
        right.addWidget(self.btn_undo)
        right.addWidget(self.btn_clear)
        right.addWidget(self.btn_del)
        right.addWidget(QLabel("标注列表："))
        right.addWidget(self.list_ann, stretch=1)
        right.addWidget(self.btn_save)
        right.addWidget(self.btn_prev)
        right.addWidget(self.btn_next)

        layout = QHBoxLayout()
        layout.addWidget(self.img_label, stretch=3)
        box_right = QWidget(); box_right.setLayout(right)
        layout.addWidget(box_right, stretch=1)

        container = QWidget(); container.setLayout(layout)
        self.setCentralWidget(container)
        self.resize(self.view_w+420, self.view_h+40)

    def update_scale(self):
        if self.img is None:
            self.scale_x = self.scale_y = 1.0
            return
        self.scale_x = self.img_w / float(self.view_w)
        self.scale_y = self.img_h / float(self.view_h)

    def load_image(self):
        if self.idx < 0: self.idx = 0
        if self.idx >= len(self.images):
            QMessageBox.information(self, "完成", "已到最后一张。")
            self.idx = len(self.images)-1
            return
        name = self.images[self.idx]
        path = os.path.join(self.image_dir, name)
        self.img = cv2.imread(path)
        if self.img is None:
            QMessageBox.warning(self, "错误", f"无法读取图像: {path}")
            return
        self.img_h, self.img_w = self.img.shape[:2]
        self.curr_poly = []
        self.annos = []
        self.list_ann.clear()
        self.update_scale()
        self.load_existing_label()
        self.redraw()

    def load_existing_label(self):
        # 根据模板找对应TXT
        img_stem = os.path.splitext(self.images[self.idx])[0]
        nf = self.cfg.number_format
        tmpl = self.cfg.naming['label_filename_template']
        fname = build_label_filename(tmpl, self.cfg.microscope, img_stem, nf)
        out_path = os.path.join(self.output_dir, fname)
        if not os.path.exists(out_path):
            return
        lines = []
        with open(out_path, 'r', encoding='utf-8') as f:
            for line in f:
                t = line.strip()
                if not t or t.startswith("#"): continue
                lines.append(t)
        for li in lines:
            parts = li.split()
            if len(parts) < 15:  # 5ID + 4bbox + >=6点
                continue
            ids = list(map(int, parts[:5]))
            bbox = list(map(float, parts[5:9]))
            seg = list(map(float, parts[9:]))
            if len(seg) % 2 != 0: continue
            # 直接保留归一化格式（内部绘制时转换）
            self.annos.append(ids + bbox + seg)
            self.list_ann.addItem(self._item_text(ids, bbox, len(seg)//2))

    def _item_text(self, ids, bbox, npts):
        b = ",".join([f"{v:.3f}" for v in bbox])
        return f"[sp={ids[0]},co={ids[1]},sh={ids[2]},fl={ids[3]},ch={ids[4]}] bbox(xc,yc,w,h)={b} pts={npts}"

    def redraw(self):
        if self.img is None: return
        disp = cv2.resize(self.img, (self.view_w, self.view_h), interpolation=cv2.INTER_AREA)
        pix = self._cv2pixmap(disp)
        painter = QPainter(pix)
        green = QPen(QColor(0,255,0), 2)
        yellow = QPen(QColor(255,215,0), 2)
        dot_brush = QBrush(QColor(255,0,0))
        # 画已有标注（绿色）
        painter.setPen(green)
        for rec in self.annos:
            seg = rec[9:]
            pts = []
            for i in range(0, len(seg), 2):
                x = seg[i] * self.img_w / self.scale_x
                y = seg[i+1] * self.img_h / self.scale_y
                pts.append((x, y))
            for i in range(len(pts)):
                x1,y1 = pts[i]
                x2,y2 = pts[(i+1)%len(pts)]
                painter.drawLine(int(x1), int(y1), int(x2), int(y2))
        # 画当前多边形（黄色）
        painter.setPen(yellow)
        for i,(ox,oy) in enumerate(self.curr_poly):
            dx, dy = ox/self.scale_x, oy/self.scale_y
            painter.setBrush(dot_brush)
            painter.drawEllipse(QPoint(int(dx), int(dy)), 3, 3)
            if i>0:
                px,py = self.curr_poly[i-1]
                painter.drawLine(int(px/self.scale_x), int(py/self.scale_y), int(dx), int(dy))
        painter.end()
        self.img_label.setPixmap(pix)

    def _cv2pixmap(self, img):
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        h,w,ch = img.shape
        qimg = QImage(img.data, w, h, ch*w, QImage.Format_RGB888)
        return QPixmap.fromImage(qimg)

    def on_mouse_press(self, event):
        if self.img is None: return
        if event.button() == Qt.LeftButton:
            ex, ey = event.pos().x(), event.pos().y()
            ox, oy = ex*self.scale_x, ey*self.scale_y
            ox = min(max(0.0, ox), self.img_w-1)
            oy = min(max(0.0, oy), self.img_h-1)
            self.curr_poly.append((ox, oy))
            self.redraw()

    def undo_point(self):
        if self.curr_poly:
            self.curr_poly.pop()
            self.redraw()

    def clear_poly(self):
        self.curr_poly = []
        self.redraw()

    def add_anno(self):
        if len(self.curr_poly) < 3:
            QMessageBox.warning(self, "提示", "请至少标注3个点。")
            return
        # 归一化
        poly_norm = [(x/self.img_w, y/self.img_h) for (x,y) in self.curr_poly]
        xs = [p[0] for p in poly_norm]; ys = [p[1] for p in poly_norm]
        x_min, x_max = min(xs), max(xs)
        y_min, y_max = min(ys), max(ys)
        xc, yc = (x_min+x_max)/2.0, (y_min+y_max)/2.0
        w, h = (x_max-x_min), (y_max-y_min)
        xc = min(max(0.0, xc), 1.0); yc = min(max(0.0, yc), 1.0)
        w = min(max(1e-6, w), 1.0); h = min(max(1e-6, h), 1.0)

        ids = [
            self.cb['species'].currentData(),
            self.cb['cell_org'].currentData(),
            self.cb['shape'].currentData(),
            self.cb['flagella'].currentData(),
            self.cb['chloroplast'].currentData()
        ]
        bbox = [round(xc,4), round(yc,4), round(w,4), round(h,4)]
        seg = []
        for (x,y) in poly_norm:
            seg.extend([round(x,4), round(y,4)])

        rec = ids + bbox + seg
        self.annos.append(rec)
        self.list_ann.addItem(self._item_text(ids, bbox, len(poly_norm)))
        self.curr_poly = []
        self.redraw()

    def del_selected(self):
        row = self.list_ann.currentRow()
        if 0 <= row < len(self.annos):
            self.annos.pop(row)
            self.list_ann.takeItem(row)
            self.redraw()

    def prev_image(self):
        self._autosave()
        self.idx -= 1
        self.load_image()

    def next_image(self):
        self._autosave()
        self.idx += 1
        self.load_image()

    def _autosave(self):
        # 可扩展为自动保存，这里保留空实现避免弹窗打断
        pass

    def save_current(self):
        if self.img is None:
            return
        img_stem = os.path.splitext(self.images[self.idx])[0]
        nf = self.cfg.number_format
        tmpl = self.cfg.naming['label_filename_template']
        fname = build_label_filename(tmpl, self.cfg.microscope, img_stem, nf)
        os.makedirs(self.output_dir, exist_ok=True)
        out_path = os.path.join(self.output_dir, fname)

        with open(out_path, 'w', encoding='utf-8') as f:
            headers = inject_headers(self.cfg.naming['header_lines'], self.cfg.microscope, nf)
            for h in headers: f.write(h+"\n")
            for rec in self.annos:
                f.write(" ".join([str(v) for v in rec]) + "\n")
        QMessageBox.information(self, "保存成功", f"已保存: {out_path}")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--image_dir", type=str, required=True, help="图像目录")
    parser.add_argument("--output_dir", type=str, required=True, help="标注输出目录")
    parser.add_argument("--cfg", type=str, required=True, help="YAML配置")
    args = parser.parse_args()

    app = QApplication(sys.argv)
    cfg = Config(args.cfg)
    win = Annotator(args.image_dir, args.output_dir, cfg)
    win.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
```

如何运行
- 准备目录：images/train 与 labels/train
- 启动GUI：
  - python tools/unified_annotator_gui.py --image_dir images/train --output_dir labels/train --cfg configs/yolov13_transformer_unified_v2_1.yaml
- 操作：
  - 左键点多边形；右侧选择 species / cell_org（含“多细胞(>4)”=44）/ shape / flagella / chloroplast
  - 点击“添加标注”提交；“保存当前图”写入TXT（自动头部与命名）
  - 加载已有TXT会叠加显示（旧10/11仍被保留，训练时会映射到“多(>4)”）

说明与兼容
- 训练时 cell_org 的 to_local 映射已兼容旧 10、11（dense_colony/colonial_cluster）为“多(>4)”的同一局部类；预测解码统一输出全局ID=44。
- 规则引擎已把“微囊藻”等群体物种的cell_org要求切换为 [7,44]（并兼容旧[10,11]）。

你先用这两样开工标注与质检，确认TXT和头部一致后，我们再对接训练（Dataset解析 + Baseline/µScale/小目标结构）。需要我顺手给你“质检脚本骨架”和“统一格式Dataset解析器”的实现清单吗？你选下一步我就给细化。